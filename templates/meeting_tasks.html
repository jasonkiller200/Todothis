<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœƒè­°ä»»å‹™æŒ‡æ´¾èˆ‡è¨˜éŒ„</title>
    <link rel="icon" href="{{ url_for('static', filename='favicon.svg') }}" type="image/svg+xml">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/flatpickr/flatpickr.min.css') }}">
    <style>
        :root {
            --color-primary: #4facfe;
            --color-secondary: #00f2fe;
            --color-background: #f0f2f5;
            --color-text: #333;
            --color-white: #fff;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; color: var(--color-text); }
        .container { max-width: 1400px; margin: 20px auto; background: var(--color-white); border-radius: 15px; box-shadow: var(--shadow); padding: 30px; }
        h1 { text-align: center; color: var(--color-primary); margin-bottom: 30px; }
        .section { margin-bottom: 40px; background: var(--color-background); padding: 25px; border-radius: 10px; box-shadow: inset 0 0 10px rgba(0,0,0,0.05); }
        .section h2 { color: var(--color-secondary); margin-bottom: 20px; text-align: center; }

        /* Form Styling */
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; }
        .form-group input[type="text"],
        .form-group input[type="date"],
        .form-group input[type="datetime-local"],
        .form-group input[type="time"],
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1.1em; /* æ”¾å¤§å­—é«” */
            margin-top: 5px;
        }
        .form-group textarea { resize: vertical; min-height: 80px; }
        .form-group button {
            background: linear-gradient(90deg, var(--color-primary), var(--color-secondary));
            color: var(--color-white);
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
            display: block;
            width: 100%;
            margin-top: 20px;
        }
        .form-group button:hover { opacity: 0.9; box-shadow: 0 5px 15px rgba(0,0,0,0.2); }
        .form-row { display: flex; gap: 20px; margin-bottom: 15px; }
        .form-row .form-group { flex: 1; margin-bottom: 0; }

        /* Error Message Styling */
        .error-message { color: red; margin-bottom: 10px; font-size: 0.9em; }

        /* Table Styling */
        table { width: 100%; border-collapse: collapse; margin-top: 20px; background: var(--color-white); border-radius: 8px; overflow: hidden; box-shadow: var(--shadow); }
        th, td { padding: 12px 15px; text-align: left; border-bottom: 1px solid #ddd; font-size: 0.9em; vertical-align: middle; word-wrap: break-word; white-space: normal; }
        th { background: linear-gradient(90deg, var(--color-primary), var(--color-secondary)); color: var(--color-white); font-weight: bold; }
        tr:nth-child(even) { background-color: #f8f8f8; }
        tr:hover { background-color: #f1f1f1; }
        .no-data { text-align: center; padding: 30px; color: #666; font-size: 1.1em; }
        .back-link { display: block; text-align: center; margin-top: 30px; }
        .back-link a { color: var(--color-primary); text-decoration: none; font-weight: bold; padding: 10px 20px; border: 2px solid var(--color-primary); border-radius: 8px; transition: all 0.3s; }
        .back-link a:hover { background: var(--color-primary); color: var(--color-white); }

        /* Modal Styling */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); }
        .modal-content { background-color: #fefefe; margin: 10% auto; padding: 30px; border: 1px solid #888; width: 80%; max-width: 600px; border-radius: 15px; box-shadow: 0 5px 25px rgba(0,0,0,0.3); position: relative; }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; position: absolute; top: 10px; right: 20px; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }

        .status-badge { display: inline-block; padding: 3px 8px; border-radius: 12px; font-size: 0.7em; font-weight: bold; }
        .status-pending { background: #f8d7da; color: #721c24; }
        .status-completed { background: #d4edda; color: #155724; }
        .status-in-progress { background: #fff3cd; color: #856404; }
        .status-unassigned { background: #e0e0e0; color: #555; }
        .status-assigned { background: #cce5ff; color: #004085; }
        .status-resolution-item { background: #d1ecf1; color: #0c5460; }

        .action-button, .assign-button {
            border: none;
            padding: 3px 8px; /* èª¿æ•´ padding ä½¿æŒ‰éˆ•è®Šå° */
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8em;
            margin: 2px;
            color: white;
            transition: background-color 0.2s ease;
        }
        .assign-button { background: #28a745; }
        .assign-button:hover { background: #218838; }
        .edit-button { background: #ffc107; }
        .edit-button:hover { background: #e0a800; }
        .delete-button { background: #dc3545; }
        .delete-button:hover { background: #c82333; }
        .save-button { background: #007bff; }
        .save-button:hover { background: #0069d9; }
        .agree-button { background: #28a745; }
        .agree-button:hover { background: #218838; }
        .task-actions { width: 120px; text-align: center; }
        .history-column { display: none; }

        .date-input-table { width: 150px; padding: 5px; border: 1px solid #ccc; border-radius: 3px; }
        .meeting-history-list { list-style: none; padding: 0; max-height: 200px; overflow-y: auto; }
        .meeting-history-list li { background: #e9ecef; margin-bottom: 8px; padding: 10px 15px; border-radius: 8px; cursor: pointer; transition: background-color 0.3s ease; display: flex; justify-content: space-between; align-items: center; }
        .meeting-history-list li:hover { background-color: #dcdcdc; }
        .meeting-history-list li span { font-size: 0.9em; color: #555; }
        .meeting-history-list li strong { color: var(--color-primary); }
        
        .meeting-section { background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        .meeting-section h3 { color: var(--color-primary); margin-bottom: 10px; text-align: center; }
        .meeting-section p { margin-bottom: 5px; font-size: 0.95em; color: #444; }
        .meeting-section h4 { color: var(--color-secondary); margin-top: 20px; margin-bottom: 10px; text-align: center; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
            <h1 style="margin: 0; color: var(--color-primary);">ğŸ“ æœƒè­°ä»»å‹™æŒ‡æ´¾èˆ‡è¨˜éŒ„</h1>
            <a href="{{ url_for('index') }}" class="btn btn-primary" style="background: #007bff; color: white;">ğŸ  è¿”å›ä¸»é </a>
        </div>

        <div class="section">
            <h2>æ–°å¢æœƒè­°ä»»å‹™</h2>
            <form id="add-meeting-task-form">
                <div class="form-row">
                    <div class="form-group">
                        <label for="meeting-topic">æœƒè­°ä¸»é¡Œ</label>
                        <input type="text" id="meeting-topic" name="meeting_topic" required>
                    </div>
                    <div class="form-group">
                        <label for="meeting-date">æœƒè­°æ—¥æœŸèˆ‡æ™‚é–“</label>
                        <input type="text" id="meeting-date" name="meeting_date" required>
                    </div>
                    <div class="form-group">
                        <label for="meeting-location">æœƒè­°åœ°é»</label>
                        <input type="text" id="meeting-location" name="location">
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="chairman-user-key">ä¸»å¸­</label>
                        <select id="chairman-user-key" name="chairman_user_key" required></select>
                    </div>
                    <div class="form-group">
                        <label for="recorder-user-key">ç´€éŒ„</label>
                        <select id="recorder-user-key" name="recorder_user_key" required></select>
                    </div>
                    <div class="form-group">
                        <label for="attendees-user-keys">å‡ºå¸­äººå“¡</label>
                        <select id="attendees-user-keys" name="attendees_user_keys" multiple required></select>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="discussion-topic">è¨è«–è­°é¡Œ</label>
                        <textarea id="discussion-topic" name="discussion_topic" rows="1" oninput="autoResizeTextarea(this)"></textarea>
                    </div>
                </div>
                <div class="form-group">
                    <button type="button" id="update-discussion-topic-button">æ›´æ–°è¨è«–è­°é¡Œ</button>
                </div>
                <hr>
                <div class="form-row">
                    <div class="form-group">
                        <label for="task-type">ä»»å‹™é¡å‹</label>
                        <select id="task-type" name="task_type" required>
                            <option value="tracking">è¿½è¹¤é …ç›®</option>
                            <option value="resolution">æ±ºè­°é …ç›®</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="assigned-to-user-key">ä¸»è¾¦è€… (è² è²¬äººå“¡)</label>
                        <select id="assigned-to-user-key" name="assigned_to_user_key" required></select>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="controller-user-key">ç®¡åˆ¶è€… (å¿…é¸)</label>
                        <select id="controller-user-key" name="controller_user_key"></select>
                    </div>
                    <div class="form-group">
                        <label for="expected-completion-date">é è¨ˆå®Œæˆæ—¥æœŸ</label>
                        <input type="date" id="expected-completion-date" name="expected_completion_date">
                        <small>è¿½è¹¤é …ç›®å¯å¾ŒçºŒå¡«å¯«ï¼Œæ±ºè­°é …ç›®å¿…å¡«</small>
                    </div>
                </div>
                <div class="form-group">
                    <label for="task-description">ä»»å‹™äº‹é …</label>
                    <textarea id="task-description" name="task_description" required></textarea>
                </div>
                <div class="form-group">
                    <button type="submit">æ–°å¢è¨˜éŒ„</button>
                </div>
            </form>
        </div>

        <div class="section">
            <h2>æœƒè­°æ­·å²è¨˜éŒ„ (é¸æ“‡è¼‰å…¥)</h2>
            <div class="form-row">
                <div class="form-group">
                    <label for="filter-year">å¹´ä»½</label>
                    <select id="filter-year" class="form-control"></select>
                </div>
                <div class="form-group">
                    <label for="filter-month">æœˆä»½</label>
                    <select id="filter-month" class="form-control"></select>
                </div>
            </div>
            <div class="form-group">
                <label for="meeting-history-select">é¸æ“‡æ­·å²æœƒè­°</label>
                <select id="meeting-history-select" class="form-control">
                    <option value="">è«‹é¸æ“‡ä¸€å€‹æœƒè­°</option>
                </select>
            </div>
        </div>

        <div class="section">
            <h2>ç¾æœ‰æœƒè­°ä»»å‹™è¨˜éŒ„</h2>
            <div class="form-group" style="text-align: right;">
                <input type="checkbox" id="toggle-history-log">
                <label for="toggle-history-log">é¡¯ç¤ºå±¥æ­·</label>
                <button id="export-discussion-pdf-button" class="action-button save-button" style="margin-left: 10px;">åŒ¯å‡ºè­°é¡Œ PDF</button>
                <button id="export-pdf-button" class="action-button save-button" style="margin-left: 10px;">åŒ¯å‡ºä»»å‹™ PDF</button>
            </div>
            <div id="meeting-records-container">
                <p class="no-data">è¼‰å…¥ä¸­...</p>
            </div>
        </div>

        
    </div>

    <!-- Edit Task Modal -->
    <div id="edit-task-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>ç·¨è¼¯æœƒè­°ä»»å‹™</h2>
            <form id="edit-task-form">
                <input type="hidden" id="edit-task-id">
                <div class="form-group">
                    <label for="edit-task-description">ä»»å‹™äº‹é …</label>
                    <textarea id="edit-task-description" name="task_description" required></textarea>
                </div>
                <div class="form-group">
                    <label for="edit-assigned-to-user-key">ä¸»è¾¦è€… (è² è²¬äººå“¡)</label>
                    <select id="edit-assigned-to-user-key" name="assigned_to_user_key" required></select>
                </div>
                <div class="form-group">
                    <label for="edit-controller-user-key">ç®¡åˆ¶è€…</label>
                    <select id="edit-controller-user-key" name="controller_user_key"></select>
                </div>
                <div class="form-group">
                    <button type="submit">å„²å­˜è®Šæ›´</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let currentSelectedMeetingTopic = null;
        let currentSelectedMeetingDate = null;
        let currentDiscussionItemId = null; // æ–°å¢è¨è«–è­°é¡Œ ID
        let allUsersData = [];

        function escapeHTML(str) {
            if (str === null || str === undefined) return '';
            return str.toString()
                .replace(/&/g, '&')
                .replace(/</g, '<')
                .replace(/>/g, '>')
                .replace(/"/g, '"')
                .replace(/'/g, '&#039;');
        }

        function getStatusText(status) {
            const statusMap = {
                'unassigned': 'å¾…æŒ‡æ´¾',
                'assigned': 'å·²æŒ‡æ´¾',
                'resolution_item': 'æ±ºè­°é …ç›®',
                'resolved_executing': 'æ±ºè­°é€šéåŸ·è¡Œ',
                'agreed_finalized': 'å·²åŒæ„ä¸¦æœ€çµ‚ç¢ºå®š',
                'completed': 'å·²å®Œæˆ',
                'in_progress_todo': 'é€²è¡Œä¸­',
                'uncompleted_todo': 'æœªå®Œæˆ'
            };
            return statusMap[status] || status;
        }

        function getStatusBadgeClass(status) {
            const classMap = {
                'unassigned': 'status-unassigned',
                'assigned': 'status-assigned',
                'resolution_item': 'status-resolution-item',
                'resolved_executing': 'status-assigned',
                'agreed_finalized': 'status-completed',
                'completed': 'status-completed'
            };
            return classMap[status] || 'status-pending';
        }

        function formatLocalDateToYYYYMMDD(date) {
            if (!date) return '';
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function formatDateForInput(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            return formatLocalDateToYYYYMMDD(date);
        }

        function autoResizeTextarea(element) {
            element.style.height = 'auto';
            element.style.height = (element.scrollHeight) + 'px';
        }

        async function saveTaskDescription(taskId, newDescription) {
            if (!newDescription.trim()) {
                alert('ä»»å‹™äº‹é …ä¸å¯ç‚ºç©ºã€‚');
                return false;
            }
            try {
                const response = await fetch(`/api/meeting_task/${taskId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ task_description: newDescription })
                });
                const result = await response.json();
                if (response.ok) {
                    alert(result.message);
                    return true;
                } else {
                    alert('æ›´æ–°å¤±æ•—: ' + result.error);
                    return false;
                }
            } catch (error) {
                console.error('Error updating task:', error);
                alert('æ›´æ–°ä»»å‹™æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚');
                return false;
            }
        }

        async function populateYearMonthFilters() {
            const yearSelect = document.getElementById('filter-year');
            const monthSelect = document.getElementById('filter-month');

            // æ¸…ç©ºç¾æœ‰é¸é …
            yearSelect.innerHTML = '';
            monthSelect.innerHTML = '';

            try {
                const response = await fetch('/api/meeting_available_dates');
                const data = await response.json();
                const availableYears = data.years;
                const availableMonths = data.months;

                const currentYear = new Date().getFullYear();
                const currentMonth = new Date().getMonth() + 1;

                // å¡«å……å¹´ä»½ä¸‹æ‹‰é¸å–®
                if (data.years.length > 0) {
                    data.years.forEach(year => {
                        const option = document.createElement('option');
                        option.value = year;
                        option.textContent = year;
                        yearSelect.appendChild(option);
                    });
                } else {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'ç„¡å¯ç”¨å¹´ä»½';
                    yearSelect.appendChild(option);
                }

                // å¡«å……æœˆä»½ä¸‹æ‹‰é¸å–®
                if (data.months.length > 0) {
                    data.months.forEach(month => {
                        const option = document.createElement('option');
                        option.value = month;
                        option.textContent = month + 'æœˆ';
                        monthSelect.appendChild(option);
                    });
                } else {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'ç„¡å¯ç”¨æœˆä»½';
                    monthSelect.appendChild(option);
                }

                // ç›´æ¥ä½¿ç”¨å¾Œç«¯æä¾›çš„é è¨­å€¼
                if (data.defaultYear) {
                    yearSelect.value = data.defaultYear;
                }
                if (data.defaultMonth) {
                    monthSelect.value = data.defaultMonth;
                }

            } catch (error) {
                console.error('Error loading available meeting dates:', error);
                // å¦‚æœè¼‰å…¥å¤±æ•—ï¼Œé¡¯ç¤ºéŒ¯èª¤è¨Šæ¯æˆ–é è¨­é¸é …
                yearSelect.innerHTML = '<option value="">è¼‰å…¥å¤±æ•—</option>';
                monthSelect.innerHTML = '<option value="">è¼‰å…¥å¤±æ•—</option>';
            }
        }

        async function loadUsersForSelects() {
            try {
                const response = await fetch('/api/all_users');
                allUsersData = await response.json();
                const selects = document.querySelectorAll('select[name="chairman_user_key"], select[name="recorder_user_key"], select[name="assigned_to_user_key"], select[name="controller_user_key"], select[name="attendees_user_keys"]');
                
                selects.forEach(select => {
                    select.innerHTML = '';
                    if (select.name === 'controller_user_key') {
                        const emptyOption = document.createElement('option');
                        emptyOption.value = '';
                        emptyOption.textContent = 'è«‹é¸æ“‡';
                        select.appendChild(emptyOption);
                    }

                    if (select.id === 'chairman-user-key') {
                        const chairmanCandidates = allUsersData.filter(user => 
                            user.level === 'executive-manager' || 
                            user.level === 'plant-manager' || 
                            user.level === 'manager'
                        );
                        chairmanCandidates.forEach(user => {
                            const option = document.createElement('option');
                            option.value = user.user_key;
                            option.textContent = `${user.name} (${user.role})`;
                            select.appendChild(option);
                        });
                        let defaultChairmanKey = '';
                        const execManagerUser = chairmanCandidates.find(user => user.user_key === 'exec_manager' && user.level === 'executive-manager');
                        if (execManagerUser) {
                            defaultChairmanKey = execManagerUser.user_key;
                        } else {
                            const firstExecManager = chairmanCandidates.find(user => user.level === 'executive-manager');
                            if (firstExecManager) {
                                defaultChairmanKey = firstExecManager.user_key;
                            }
                        }
                        select.value = defaultChairmanKey;
                    } else if (select.id === 'recorder-user-key') {
                        const recorderCandidates = allUsersData.filter(user => 
                            user.level === 'section-chief' || 
                            user.level === 'deputy-section-chief' || 
                            user.level === 'team-leader'
                        );
                        recorderCandidates.forEach(user => {
                            const option = document.createElement('option');
                            option.value = user.user_key;
                            option.textContent = `${user.name} (${user.role})`;
                            select.appendChild(option);
                        });
                        // é è¨­é¸æ“‡ç¬¬ä¸€å€‹å¯ç”¨çš„ç´€éŒ„äººå“¡ï¼Œå¦‚æœæ²’æœ‰å‰‡ç‚ºç©º
                        if (recorderCandidates.length > 0) {
                            select.value = recorderCandidates[0].user_key;
                        } else {
                            select.value = '';
                        }
                    } else if (select.id === 'assigned-to-user-key') {
                        const emptyOption = document.createElement('option');
                        emptyOption.value = '';
                        emptyOption.textContent = 'è«‹é¸æ“‡';
                        select.appendChild(emptyOption);

                        allUsersData.forEach(user => {
                            if (user.level !== 'admin') {
                                const option = document.createElement('option');
                                option.value = user.user_key;
                                option.textContent = `${user.name} (${user.role})`;
                                select.appendChild(option);
                            }
                        });
                        select.value = '';
                    } else { // This block handles attendees_user_keys
                        allUsersData.forEach(user => {
                            if (user.level !== 'admin') {
                                const option = document.createElement('option');
                                option.value = user.user_key;
                                option.textContent = `${user.name} (${user.role})`;
                                select.appendChild(option);
                            }
                        });
                    }
                });
            } catch (error) {
                console.error('Error loading users:', error);
                alert('ç„¡æ³•è¼‰å…¥ä½¿ç”¨è€…åˆ—è¡¨ã€‚');
            }
        }

        function getUserNameByKey(userKey) {
            const user = allUsersData.find(u => u.user_key === userKey);
            return user ? `${user.name} (${user.role})` : 'æœªçŸ¥ä½¿ç”¨è€…';
        }

        async function loadMeetingTasks(filterTopic = null, filterDate = null) {
            const container = document.getElementById('meeting-records-container');
            container.innerHTML = '';
            if (!filterTopic && !filterDate) {
                container.innerHTML = '<p class="no-data">è«‹å¾ä¸Šæ–¹é¸æ“‡ä¸€å€‹æœƒè­°ä»¥æŸ¥çœ‹å…¶ä»»å‹™è¨˜éŒ„ã€‚</p>';
                currentSelectedMeetingTopic = null;
                currentSelectedMeetingDate = null;
                return;
            }

            currentSelectedMeetingTopic = filterTopic;
            currentSelectedMeetingDate = filterDate;
            try {
                let url = '/api/meeting_tasks_list';
                const params = new URLSearchParams();
                if (filterTopic) params.append('meeting_topic', filterTopic);
                if (filterDate) params.append('meeting_date', filterDate);
                if (params.toString()) url += `?${params.toString()}`;

                const response = await fetch(url);
                let tasks = await response.json();

                // ç§»é™¤å‰ç«¯éæ¿¾é‚è¼¯ï¼Œå› ç‚ºå¾Œç«¯å·²ç¶“è™•ç†äº†éæ¿¾
                // if (filterTopic && filterDate) {
                //     tasks = tasks.filter(task => 
                //         task.meeting_topic === filterTopic && 
                //         new Date(task.meeting_date).toISOString().split('T')[0] === new Date(filterDate).toISOString().split('T')[0]
                //     );
                // }

                if (tasks.length === 0) {
                    container.innerHTML = '<p class="no-data">æš«ç„¡æœƒè­°ä»»å‹™è¨˜éŒ„ã€‚</p>';
                    return;
                }

                const meetings = {};
                tasks.forEach(task => {
                    const meetingKey = `${task.meeting_topic}-${task.meeting_date}`;
                    if (!meetings[meetingKey]) {
                        meetings[meetingKey] = {
                            meeting_topic: task.meeting_topic,
                            meeting_date: task.meeting_date,
                            chairman_name: task.chairman_name,
                            attendees_names: task.attendees_names,
                            recorder_name: task.recorder_name, // æ–°å¢ recorder_name
                            discussion_topic: task.discussion_topic, // æ–°å¢ discussion_topic
                            tracking_items: [],
                            resolution_items: []
                        };
                    }
                    if (task.task_type === 'tracking') {
                        meetings[meetingKey].tracking_items.push(task);
                    } else {
                        meetings[meetingKey].resolution_items.push(task);
                    }
                });

                for (const meetingKey in meetings) {
                    const meeting = meetings[meetingKey];
                    const meetingSection = document.createElement('div');
                    meetingSection.classList.add('meeting-section');

                    const attendeesText = meeting.attendees_names && Array.isArray(meeting.attendees_names) ? meeting.attendees_names.join(', ') : 'ç„¡';

                    meetingSection.innerHTML = `
                        <h3>æœƒè­°ä¸»é¡Œ: ${meeting.meeting_topic}</h3>
                        <p><strong>æœƒè­°æ—¥æœŸ:</strong> ${new Date(meeting.meeting_date).toLocaleDateString('zh-TW')}</p>
                        <p><strong>ä¸»å¸­:</strong> ${meeting.chairman_name}</p>
                        <p><strong>ç´€éŒ„:</strong> ${meeting.recorder_name || 'ç„¡'}</p>
                        <p><strong>å‡ºå¸­äººå“¡:</strong> ${attendeesText}</p>

                        <h4>è¿½è¹¤é …ç›®</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>ä»»å‹™äº‹é …</th>
                                    <th>ä¸»è¾¦è€…</th>
                                    <th>ç®¡åˆ¶è€…</th>
                                    <th>é è¨ˆå®Œæˆæ—¥æœŸ</th>
                                    <th>å¯¦éš›å®Œæˆæ—¥æœŸ</th>
                                    <th>ç‹€æ…‹</th>
                                    <th class="history-column">å±¥æ­·</th>
                                    <th class="task-actions">æ“ä½œ</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${meeting.tracking_items.length > 0 ? meeting.tracking_items.map(task => `
                                    <tr data-task-id="${task.id}">
                                        <td class="task-description-cell">${task.task_description}</td>
                                        <td>${task.assigned_to_name}</td>
                                        <td>${task.controller_name || 'ç„¡'}</td>
                                        <td>
                                            ${task.is_assigned_to_todo ? 
                                                (task.expected_completion_date ? new Date(task.expected_completion_date).toLocaleDateString('zh-TW') : 'æœªè¨­å®š') :
                                                `<input type="date" class="date-input-table" value="${formatDateForInput(task.expected_completion_date)}">
                                                 <button class="assign-button" data-task-id="${task.id}">ç¢ºèªæŒ‡æ´¾</button>`
                                            }
                                        </td>
                                        <td>${task.actual_completion_date ? new Date(task.actual_completion_date).toLocaleDateString('zh-TW') : 'æœªå®Œæˆ'}</td>
                                        <td><span class="status-badge ${getStatusBadgeClass(task.status)}">${getStatusText(task.status)}</span></td>
                                        <td class="history-column">
                                            ${task.history_log && task.history_log.length > 0 ? 
                                                `<div class="todo-history">
                                                    ${task.history_log.map(entry => {
                                                        let eventText = '';
                                                        const date = new Date(entry.timestamp);
                                                        const timestamp = date.toLocaleString('zh-TW', { year: 'numeric', month: 'numeric', day: 'numeric', hour: 'numeric', minute: 'numeric', hour12: false, timeZone: 'Asia/Taipei' });
                                                        const actorName = entry.actor ? `ç”± ${escapeHTML(entry.actor.name)}` : '';

                                                        if (entry.event_type === 'created') {
                                                            eventText = `ä»»å‹™å·²å»ºç«‹`;
                                                        } else if (entry.event_type === 'updated') {
                                                            eventText = `${actorName} æ›´æ–°äº†ä»»å‹™äº‹é …`;
                                                        } else if (entry.event_type === 'assigned_to_todo') {
                                                            const assignedToName = escapeHTML(entry.details.assigned_to_user.name);
                                                            const assignedByName = escapeHTML(entry.details.assigned_by_user.name);
                                                            eventText = `ç”± ${assignedByName} æŒ‡æ´¾çµ¦ ${assignedToName} (å·²è½‰ç‚ºå¾…è¾¦äº‹é …)`;
                                                        } else if (entry.event_type === 'agreed_finalized') {
                                                            eventText = `${actorName} åŒæ„ä¸¦æœ€çµ‚ç¢ºå®šäº†æ±ºè­°`;
                                                        }
                                                        return `<div class="history-item">${eventText} (${timestamp})</div>`;
                                                    }).join('')}
                                                </div>` : 'ç„¡å±¥æ­·'
                                            }
                                        </td>
                                        <td class="task-actions">
                                            ${!task.is_assigned_to_todo ? 
                                                `<button class="action-button edit-button" 
                                                         data-task-id="${task.id}" 
                                                         data-task-description="${escapeHTML(task.task_description)}"
                                                         data-assigned-to-key="${task.assigned_to_user_key || ''}"
                                                         data-controller-key="${task.controller_user_key || ''}">ç·¨è¼¯</button>
                                                 <button class="action-button delete-button" data-task-id="${task.id}">åˆªé™¤</button>` : ''
                                            }
                                        </td>
                                    </tr>
                                `).join('') : '<tr><td colspan="7" class="no-data">æš«ç„¡è¿½è¹¤é …ç›®ã€‚</td></tr>'}
                            </tbody>
                        </table>

                        <h4>æ±ºè­°é …ç›®</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>ä»»å‹™äº‹é …</th>
                                    <th>ä¸»è¾¦è€…</th>
                                    <th>ç®¡åˆ¶è€…</th>
                                    <th>é–‹å§‹åŸ·è¡Œæ—¥æœŸ</th>
                                    <th>ç‹€æ…‹</th>
                                    <th class="history-column">å±¥æ­·</th>
                                    <th class="task-actions">æ“ä½œ</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${meeting.resolution_items.length > 0 ? meeting.resolution_items.map(task => `
                                    <tr data-task-id="${task.id}">
                                        <td class="task-description-cell">${task.task_description}</td>
                                        <td>${task.assigned_to_name}</td>
                                        <td>${task.controller_name || 'ç„¡'}</td>
                                        <td>${task.expected_completion_date ? new Date(task.expected_completion_date).toLocaleDateString('zh-TW') : 'æœªè¨­å®š'}</td>
                                        <td><span class="status-badge ${getStatusBadgeClass(task.status)}">${getStatusText(task.status)}</span></td>
                                        <td class="history-column">
                                            ${task.history_log && task.history_log.length > 0 ? 
                                                `<div class="todo-history">
                                                    ${task.history_log.map(entry => {
                                                        let eventText = '';
                                                        const date = new Date(entry.timestamp);
                                                        const timestamp = date.toLocaleString('zh-TW', { year: 'numeric', month: 'numeric', day: 'numeric', hour: 'numeric', minute: 'numeric', hour12: false, timeZone: 'Asia/Taipei' });
                                                        const actorName = entry.actor ? `ç”± ${escapeHTML(entry.actor.name)}` : '';

                                                        if (entry.event_type === 'created') {
                                                            eventText = `ä»»å‹™å·²å»ºç«‹`;
                                                        } else if (entry.event_type === 'updated') {
                                                            eventText = `${actorName} æ›´æ–°äº†ä»»å‹™äº‹é …`;
                                                        } else if (entry.event_type === 'assigned_to_todo') {
                                                            const assignedToName = escapeHTML(entry.details.assigned_to_user.name);
                                                            const assignedByName = escapeHTML(entry.details.assigned_by_user.name);
                                                            eventText = `ç”± ${assignedByName} æŒ‡æ´¾çµ¦ ${assignedToName} (å·²è½‰ç‚ºå¾…è¾¦äº‹é …)`;
                                                        } else if (entry.event_type === 'agreed_finalized') {
                                                            eventText = `${actorName} åŒæ„ä¸¦æœ€çµ‚ç¢ºå®šäº†æ±ºè­°`;
                                                        }
                                                        return `<div class="history-item">${eventText} (${timestamp})</div>`;
                                                    }).join('')}
                                                </div>` : 'ç„¡å±¥æ­·'
                                            }
                                        </td>
                                        <td class="task-actions">
                                            ${task.status === 'resolved_executing' ? 
                                                `<button class="action-button agree-button" data-task-id="${task.id}">åŒæ„</button>` : ''
                                            }
                                            ${task.status !== 'agreed_finalized' ? 
                                                `<button class="action-button edit-button" 
                                                         data-task-id="${task.id}" 
                                                         data-task-description="${escapeHTML(task.task_description)}"
                                                         data-assigned-to-key="${task.assigned_to_user_key || ''}"
                                                         data-controller-key="${task.controller_user_key || ''}">ç·¨è¼¯</button>
                                                 <button class="action-button delete-button" data-task-id="${task.id}">åˆªé™¤</button>` : ''
                                            }
                                        </td>
                                    </tr>
                                `).join('') : '<tr><td colspan="6" class="no-data">æš«ç„¡æ±ºè­°é …ç›®ã€‚</td></tr>'}
                            </tbody>
                        </table>
                        <hr style="margin: 20px 0; border-color: #eee;">
                    `;
                    container.appendChild(meetingSection);
                }
            } catch (error) {
                console.error('Error loading meeting tasks:', error);
                document.getElementById('meeting-records-container').innerHTML = '<p class="no-data">ç„¡æ³•è¼‰å…¥æœƒè­°ä»»å‹™è¨˜éŒ„ã€‚</p>';
            }
        }

        async function loadMeetingHistory(year = null, month = null) {
            try {
                let url = '/api/meeting_history';
                const params = new URLSearchParams();
                if (year) params.append('year', year);
                if (month) params.append('month', month);
                if (params.toString()) url += `?${params.toString()}`;

                const response = await fetch(url);
                const history = await response.json();
                const select = document.getElementById('meeting-history-select');
                select.innerHTML = '<option value="">è«‹é¸æ“‡ä¸€å€‹æœƒè­°</option>';
                if (history.length === 0) {
                    return;
                }
                history.forEach(meeting => {
                    const option = document.createElement('option');
                    // å°‡ meeting_topic å’Œ meeting_date çµ„åˆä½œç‚º value
                    option.value = `${meeting.meeting_topic}|${meeting.meeting_date}`;
                    option.textContent = `${meeting.meeting_topic} - ${meeting.chairman_name} (${meeting.meeting_date})`;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading meeting history:', error);
                const select = document.getElementById('meeting-history-select');
                select.innerHTML = '<option value="">ç„¡æ³•è¼‰å…¥æ­·å²è¨˜éŒ„</option>';
            }
        }

        

        document.addEventListener('DOMContentLoaded', async function() {
            // --- START: Add date validation --- 
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Set to midnight to compare dates correctly
            const todayString = today.toISOString().split('T')[0];

            function setupDateInputValidation(dateInput) {
                if (!dateInput) return;

                // 1. Set min attribute to prevent selecting past dates
                // dateInput.min = todayString;

                // 2. Add event listener to check for weekends
                dateInput.addEventListener('change', function() {
                    const selectedDate = new Date(this.value + 'T00:00:00');
                    const dayOfWeek = selectedDate.getDay();

                    if (dayOfWeek === 0 || dayOfWeek === 6) { // 0 = Sunday, 6 = Saturday
                        alert('é è¨ˆå®Œæˆæ—¥æœŸä¸èƒ½æ˜¯é€±æœ«ï¼Œè«‹é¸æ“‡é€±ä¸€è‡³é€±äº”ã€‚');
                        this.value = '';
                    }
                });
            }

            // Apply validation to all date inputs on the page
            document.querySelectorAll('input[type="date"]').forEach(setupDateInputValidation);
            // --- END: Add date validation ---

            await loadUsersForSelects();
            await populateYearMonthFilters();

            // Initialize Flatpickr for meeting-date input
            flatpickr("#meeting-date", {
                enableTime: true,
                noCalendar: false,
                dateFormat: "Y-m-d H:i",
                minuteIncrement: 15,
                time_24hr: true, // Use 24-hour format
                locale: "zh_tw" // Set locale to Traditional Chinese (corrected from zh-tw)
            });

            const initialYear = document.getElementById('filter-year').value;
            const initialMonth = document.getElementById('filter-month').value;
            await loadMeetingHistory(initialYear, initialMonth);
            await loadMeetingTasks();

            // æ ¹æ“šè¡¨å–®çš„åˆå§‹å€¼è¨­å®š currentSelectedMeetingTopic å’Œ currentSelectedMeetingDate
            const initialMeetingTopic = document.getElementById('meeting-topic').value;
            const initialMeetingDate = document.getElementById('meeting-date').value;
            if (initialMeetingTopic && initialMeetingDate) {
                currentSelectedMeetingTopic = initialMeetingTopic;
                currentSelectedMeetingDate = initialMeetingDate;
            }

            // è™•ç†å±¥æ­·é¡¯ç¤º/éš±è—
            const toggleHistoryLogCheckbox = document.getElementById('toggle-history-log');
            function updateHistoryColumnVisibility() {
                const historyColumns = document.querySelectorAll('.history-column');
                historyColumns.forEach(col => {
                    col.style.display = toggleHistoryLogCheckbox.checked ? 'table-cell' : 'none';
                });
            }

            // åˆå§‹è¼‰å…¥æ™‚è¨­å®šé¡¯ç¤ºç‹€æ…‹
            updateHistoryColumnVisibility();

            // ç›£è½å‹¾é¸æ¡†è®ŠåŒ–
            toggleHistoryLogCheckbox.addEventListener('change', updateHistoryColumnVisibility);

            // åŒ¯å‡º PDF æŒ‰éˆ•äº‹ä»¶ç›£è½å™¨
            document.getElementById('export-pdf-button').addEventListener('click', async function() {
                if (!currentSelectedMeetingTopic || !currentSelectedMeetingDate) {
                    alert('è«‹å…ˆé¸æ“‡ä¸€å€‹æœƒè­°ä»¥åŒ¯å‡º PDFã€‚');
                    return;
                }

                try {
                    const response = await fetch('/api/export_meeting_tasks_pdf', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            meeting_topic: currentSelectedMeetingTopic,
                            meeting_date: currentSelectedMeetingDate
                        }),
                    });

                    if (response.ok) {
                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.style.display = 'none';
                        a.href = url;
                        a.download = `æœƒè­°ä»»å‹™_${currentSelectedMeetingTopic}_${currentSelectedMeetingDate}.pdf`;
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        alert('PDF åŒ¯å‡ºæˆåŠŸï¼');
                    } else {
                        const errorData = await response.json();
                        alert('PDF åŒ¯å‡ºå¤±æ•—: ' + (errorData.error || 'æœªçŸ¥éŒ¯èª¤'));
                    }
                } catch (error) {
                    console.error('åŒ¯å‡º PDF æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    alert('åŒ¯å‡º PDF æ™‚ç™¼ç”Ÿç¶²è·¯éŒ¯èª¤ã€‚');
                }
            });

            // åŒ¯å‡ºè­°é¡Œ PDF æŒ‰éˆ•äº‹ä»¶ç›£è½å™¨
            document.getElementById('export-discussion-pdf-button').addEventListener('click', async function() {
                if (!currentSelectedMeetingTopic || !currentSelectedMeetingDate) {
                    alert('è«‹å…ˆé¸æ“‡ä¸€å€‹æœƒè­°ä»¥åŒ¯å‡ºè­°é¡Œ PDFã€‚');
                    return;
                }

                try {
                    const response = await fetch('/api/export_discussion_items_pdf', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            meeting_topic: currentSelectedMeetingTopic,
                            meeting_date: currentSelectedMeetingDate
                        }),
                    });

                    if (response.ok) {
                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.style.display = 'none';
                        a.href = url;
                        a.download = `æœƒè­°è­°é¡Œ_${currentSelectedMeetingTopic}_${currentSelectedMeetingDate}.pdf`;
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        alert('è­°é¡Œ PDF åŒ¯å‡ºæˆåŠŸï¼');
                    } else {
                        const errorData = await response.json();
                        alert('è­°é¡Œ PDF åŒ¯å‡ºå¤±æ•—: ' + (errorData.error || 'æœªçŸ¥éŒ¯èª¤'));
                    }
                } catch (error) {
                    console.error('åŒ¯å‡ºè­°é¡Œ PDF æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    alert('åŒ¯å‡ºè­°é¡Œ PDF æ™‚ç™¼ç”Ÿç¶²è·¯éŒ¯èª¤ã€‚');
                }
            });

            document.getElementById('filter-year').addEventListener('change', async function() {
                const year = this.value;
                const month = document.getElementById('filter-month').value;
                document.getElementById('meeting-history-select').value = '';
                await loadMeetingHistory(year, month);
                await loadMeetingTasks();
            });

            document.getElementById('filter-month').addEventListener('change', async function() {
                const year = document.getElementById('filter-year').value;
                const month = this.value;
                document.getElementById('meeting-history-select').value = '';
                currentSelectedMeetingTopic = null;
                currentSelectedMeetingDate = null;
                await loadMeetingHistory(year, month);
                await loadMeetingTasks();
            });

            const expectedCompletionDateInput = document.getElementById('expected-completion-date');
            if (expectedCompletionDateInput) {
                expectedCompletionDateInput.addEventListener('change', function() {
                    const selectedDate = new Date(this.value + 'T00:00:00');
                    const dayOfWeek = selectedDate.getDay();

                    if (dayOfWeek === 0 || dayOfWeek === 6) {
                        alert('é è¨ˆå®Œæˆæ—¥æœŸä¸èƒ½æ˜¯é€±æœ«ï¼Œè«‹é¸æ“‡é€±ä¸€è‡³é€±äº”ã€‚');
                        this.value = '';
                    }
                });
            }

            document.getElementById('meeting-history-select').addEventListener('change', async function(event) {
                const selectedValue = event.target.value;
                if (selectedValue) {
                    const [selectedTopic, selectedDate] = selectedValue.split('|');
                    
                    // å‘¼å«æ–°çš„ API ç²å–æœƒè­°è©³ç´°è³‡è¨Š
                    try {
                        const response = await fetch(`/api/get_meeting_details_by_topic_date?meeting_topic=${encodeURIComponent(selectedTopic)}&meeting_date=${encodeURIComponent(selectedDate)}`);
                        const meetingDetails = await response.json();

                        if (response.ok) {
                            // å¡«å……è¡¨å–®
                            document.getElementById('meeting-topic').value = meetingDetails.meeting_topic || '';
                            document.getElementById('meeting-location').value = meetingDetails.location || '';
                            document.getElementById('meeting-date').value = meetingDetails.meeting_date || '';
                            document.getElementById('chairman-user-key').value = meetingDetails.chairman_user_key || '';
                            document.getElementById('recorder-user-key').value = meetingDetails.recorder_user_key || ''; // å¡«å……è¨˜éŒ„äººå“¡
                            
                            // è™•ç†å‡ºå¸­äººå“¡
                            const attendeesSelect = document.getElementById('attendees-user-keys');
                            Array.from(attendeesSelect.options).forEach(option => {
                                option.selected = meetingDetails.attendees_user_keys && meetingDetails.attendees_user_keys.includes(option.value);
                            });

                            document.getElementById('discussion-topic').value = meetingDetails.discussion_topic || '';
                            currentDiscussionItemId = meetingDetails.discussion_item_id; // å„²å­˜è¨è«–è­°é¡Œ ID

                            // æ›´æ–°å…¨åŸŸè®Šæ•¸ï¼Œä½¿ç”¨å¾ API å›å‚³çš„ã€æ ¼å¼æ­£ç¢ºçš„è©³ç´°è³‡æ–™
                            currentSelectedMeetingTopic = meetingDetails.meeting_topic;
                            currentSelectedMeetingDate = meetingDetails.meeting_date;
                            await loadMeetingTasks(currentSelectedMeetingTopic, currentSelectedMeetingDate);
                        } else {
                            alert('è¼‰å…¥æœƒè­°è©³ç´°è³‡è¨Šå¤±æ•—: ' + (meetingDetails.error || 'æœªçŸ¥éŒ¯èª¤'));
                            // å¦‚æœè¼‰å…¥å¤±æ•—ï¼Œæ¸…ç©ºè¡¨å–®ä¸¦é‡ç½®é¡¯ç¤º
                            document.getElementById('meeting-topic').value = '';
                            document.getElementById('meeting-date').value = '';
                            document.getElementById('chairman-user-key').value = '';
                            document.getElementById('recorder-user-key').value = '';
                            Array.from(document.getElementById('attendees-user-keys').options).forEach(option => {
                                option.selected = false;
                            });
                            document.getElementById('discussion-topic').value = '';
                            document.getElementById('task-type').value = 'tracking';
                            document.getElementById('assigned-to-user-key').value = '';
                            document.getElementById('controller-user-key').value = '';
                            document.getElementById('expected-completion-date').value = '';
                            document.getElementById('task-description').value = '';

                            currentSelectedMeetingTopic = null;
                            currentSelectedMeetingDate = null;
                            await loadMeetingTasks();
                            const year = document.getElementById('filter-year').value;
                            const month = document.getElementById('filter-month').value;
                            await loadMeetingHistory(year, month);
                        }
                    } catch (error) {
                        console.error('Error fetching meeting details:', error);
                        alert('ç²å–æœƒè­°è©³ç´°è³‡è¨Šæ™‚ç™¼ç”Ÿç¶²è·¯éŒ¯èª¤ã€‚');
                    }

                } else {
                    // å¦‚æœé¸æ“‡äº†ã€Œè«‹é¸æ“‡ä¸€å€‹æœƒè­°ã€ï¼Œå‰‡æ¸…ç©ºæ‰€æœ‰ç›¸é—œå…§å®¹
                    document.getElementById('meeting-topic').value = '';
                    document.getElementById('meeting-location').value = '';
                    document.getElementById('meeting-date').value = '';
                    document.getElementById('chairman-user-key').value = '';
                    document.getElementById('recorder-user-key').value = '';
                    Array.from(document.getElementById('attendees-user-keys').options).forEach(option => {
                        option.selected = false;
                    });
                    document.getElementById('discussion-topic').value = '';
                    document.getElementById('task-type').value = 'tracking';
                    document.getElementById('assigned-to-user-key').value = '';
                    document.getElementById('controller-user-key').value = '';
                    document.getElementById('expected-completion-date').value = '';
                    document.getElementById('task-description').value = '';

                    currentSelectedMeetingTopic = null;
                    currentSelectedMeetingDate = null;
                    await loadMeetingTasks();
                    const year = document.getElementById('filter-year').value;
                    const month = document.getElementById('filter-month').value;
                    await loadMeetingHistory(year, month);
                }
            });

            const form = document.getElementById('add-meeting-task-form');
            form.addEventListener('submit', async function(event) {
                event.preventDefault();
                const assignedTo = document.getElementById('assigned-to-user-key').value;
                const taskType = document.getElementById('task-type').value;
                const expectedCompletionDate = document.getElementById('expected-completion-date').value;
                const controller = document.getElementById('controller-user-key').value;

                function showError(message, focusElementId) {
                    const errorContainer = document.createElement('div');
                    errorContainer.className = 'error-message';
                    errorContainer.textContent = message;
                    const form = document.getElementById('add-meeting-task-form');
                    if (!form.querySelector('.error-message')) {
                        form.prepend(errorContainer);
                    }
                    setTimeout(() => errorContainer.remove(), 5000);
                    if (focusElementId) {
                        document.getElementById(focusElementId).focus();
                    }
                }

                if (!document.getElementById('meeting-topic').value) {
                    showError('è«‹å¡«å¯«æœƒè­°ä¸»é¡Œã€‚', 'meeting-topic');
                    return;
                }
                if (!document.getElementById('meeting-date').value) {
                    showError('è«‹é¸æ“‡æœƒè­°æ—¥æœŸã€‚', 'meeting-date');
                    return;
                }
                if (!document.getElementById('discussion-topic').value.trim()) {
                    showError('è«‹å¡«å¯«è¨è«–è­°é¡Œã€‚', 'discussion-topic');
                    return;
                }
                if (!assignedTo) {
                    showError('è«‹é¸æ“‡ä¸»è¾¦è€…ã€‚', 'assigned-to-user-key')
                    return;
                }
                if (!assignedTo) {
                    showError('è«‹é¸æ“‡ç®¡åˆ¶è€…ã€‚', 'controller-user-key')
                    return;
                }
                if (taskType === 'resolution' && !expectedCompletionDate) {
                    showError('æ±ºè­°é …ç›®å¿…é ˆå¡«å¯«é è¨ˆå®Œæˆæ—¥æœŸã€‚', 'expected-completion-date');
                    return;
                }

                const formData = new FormData(form);
                const data = Object.fromEntries(formData.entries());
                data.attendees_user_keys = Array.from(document.getElementById('attendees-user-keys').selectedOptions).map(opt => opt.value);
                data.recorder_user_key = document.getElementById('recorder-user-key').value;
                data.discussion_topic = document.getElementById('discussion-topic').value; // æ–°å¢è¨è«–è­°é¡Œ
                data.location = document.getElementById('meeting-location').value; // æ–°å¢æœƒè­°åœ°é»

                const taskTypeDisplay = data.task_type === 'tracking' ? 'è¿½è¹¤é …ç›®' : 'æ±ºè­°é …ç›®';
                const assignedToName = getUserNameByKey(data.assigned_to_user_key);
                const controllerName = data.controller_user_key ? getUserNameByKey(data.controller_user_key) : 'ç„¡';

                const confirmationMessage = `è«‹ç¢ºèªä»¥ä¸‹ä»»å‹™è³‡è¨Šï¼š\n\nä»»å‹™é¡å‹ï¼š${taskTypeDisplay}\nä¸»è¾¦è€…ï¼š${assignedToName}\nç®¡åˆ¶è€…ï¼š${controllerName}\n\næ˜¯å¦ç¢ºèªæ–°å¢æ­¤ä»»å‹™ï¼Ÿ`;

                if (!confirm(confirmationMessage)) {
                    return;
                }

                // Explicitly handle location to ensure it's sent as null if empty
                const meetingLocationInput = document.getElementById('meeting-location');
                if (meetingLocationInput && meetingLocationInput.value.trim() === '') {
                    data.location = null;
                } else if (meetingLocationInput) {
                    data.location = meetingLocationInput.value.trim();
                } else {
                    data.location = null; // Fallback if input element is not found
                }

                try {
                    const response = await fetch('/api/add_meeting_task', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    const result = await response.json();
                    if (response.ok) {
                        alert(result.message);
                        document.getElementById('task-type').value = 'tracking';
                        document.getElementById('assigned-to-user-key').value = '';
                        document.getElementById('controller-user-key').value = '';
                        document.getElementById('expected-completion-date').value = '';
                        document.getElementById('task-description').value = '';
                        await loadMeetingTasks(currentSelectedMeetingTopic, currentSelectedMeetingDate);
                        await loadMeetingHistory();
                    } else {
                        alert('æ–°å¢å¤±æ•—: ' + result.error);
                    }
                } catch (error) {
                    console.error('Error adding meeting task:', error);
                    alert('æ–°å¢æœƒè­°ä»»å‹™æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚');
                }
            });

            document.getElementById('meeting-records-container').addEventListener('click', async function(event) {
                const target = event.target;
                const taskId = target.dataset.taskId;

                if (target.classList.contains('assign-button')) {
                    const tr = target.closest('tr');
                    const descriptionCell = tr.querySelector('.task-description-cell');
                    const taskId = target.dataset.taskId;

                    const textarea = descriptionCell.querySelector('textarea');
                    if (textarea) {
                        const newDescription = textarea.value;
                        const saveSuccess = await saveTaskDescription(taskId, newDescription);
                        if (!saveSuccess) {
                            return;
                        }
                        descriptionCell.innerHTML = newDescription;
                        const saveButton = tr.querySelector('.save-button');
                        if (saveButton) {
                            saveButton.textContent = 'ç·¨è¼¯';
                            saveButton.classList.remove('save-button');
                            saveButton.classList.add('edit-button');
                        }
                    }

                    const dateInput = tr.querySelector('.date-input-table');
                    const expected_completion_date = dateInput.value;
                    if (!expected_completion_date) {
                        alert('è«‹å…ˆé¸æ“‡é è¨ˆå®Œæˆæ—¥æœŸå†æŒ‡æ´¾ã€‚');
                        return;
                    }
                    try {
                        const response = await fetch(`/api/assign_tracking_task_to_todo/${taskId}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ expected_completion_date })
                        });
                        const result = await response.json();
                        if (response.ok) {
                            alert(result.message);
                            await loadMeetingTasks(currentSelectedMeetingTopic, currentSelectedMeetingDate);
                        } else {
                            alert('æŒ‡æ´¾å¤±æ•—: ' + result.error);
                        }
                    } catch (error) {
                        console.error('Error assigning task:', error);
                        alert('æŒ‡æ´¾ä»»å‹™æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚');
                    }
                } else if (target.classList.contains('agree-button')) {
                    if (!confirm('ç¢ºå®šè¦åŒæ„æ­¤æ±ºè­°ä¸¦æœ€çµ‚ç¢ºå®šå—ï¼Ÿæ­¤æ“ä½œå°‡é–å®šå…§å®¹ï¼Œç„¡æ³•å†ç·¨è¼¯æˆ–åˆªé™¤ã€‚')) {
                        return;
                    }

                    try {
                        const response = await fetch(`/api/meeting_task/${taskId}/agree`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' }
                        });
                        const result = await response.json();
                        if (response.ok) {
                            alert(result.message);
                            await loadMeetingTasks(currentSelectedMeetingTopic, currentSelectedMeetingDate);
                        } else {
                            alert('åŒæ„å¤±æ•—: ' + result.error);
                        }
                    } catch (error) {
                        console.error('Error agreeing task:', error);
                        alert('åŒæ„æ±ºè­°æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚');
                    }
                } else if (target.classList.contains('edit-button')) {
                    const modal = document.getElementById('edit-task-modal');
                    const taskId = target.dataset.taskId;
                    const taskDescription = target.dataset.taskDescription;
                    const assignedToKey = target.dataset.assignedToKey;
                    const controllerKey = target.dataset.controllerKey;

                    // Populate modal fields
                    document.getElementById('edit-task-id').value = taskId;
                    document.getElementById('edit-task-description').value = taskDescription;

                    // Fetch permissions for the current user and task
                    const taskDetailsResponse = await fetch(`/api/meeting_task/${taskId}`);
                    const taskDetails = await taskDetailsResponse.json();
                    const canEditAssigneeFields = taskDetails.permissions.can_edit_assignee_fields;

                    // Populate and set select options
                    const assignedToSelect = document.getElementById('edit-assigned-to-user-key');
                    const controllerSelect = document.getElementById('edit-controller-user-key');
                    assignedToSelect.innerHTML = '';
                    controllerSelect.innerHTML = '';

                    allUsersData.forEach(user => {
                        if (user.level !== 'admin') {
                            const option = document.createElement('option');
                            option.value = user.user_key.trim();
                            option.textContent = `${user.name} (${user.role})`;
                            assignedToSelect.appendChild(option.cloneNode(true));
                            controllerSelect.appendChild(option);
                        }
                    });

                    const trimmedAssignedToKey = assignedToKey.trim();
                    const trimmedControllerKey = controllerKey.trim();
                    
                    setTimeout(() => {
                        assignedToSelect.value = trimmedAssignedToKey;
                        controllerSelect.value = trimmedControllerKey;
                    }, 0);

                    // Show/hide assignee fields based on permissions
                    const assignedToGroup = assignedToSelect.closest('.form-group');
                    const controllerGroup = controllerSelect.closest('.form-group');

                    if (canEditAssigneeFields) {
                        assignedToGroup.style.display = 'block';
                        controllerGroup.style.display = 'block';
                    } else {
                        assignedToGroup.style.display = 'none';
                        controllerGroup.style.display = 'none';
                    }
                    
                    modal.style.display = 'block';
                } else if (target.classList.contains('delete-button')) {
                    if (!confirm('ç¢ºå®šè¦åˆªé™¤æ­¤ä»»å‹™å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚')) {
                        return;
                    }

                    try {
                        const response = await fetch(`/api/meeting_task/${taskId}`, {
                            method: 'DELETE'
                        });
                        const result = await response.json();
                        if (response.ok) {
                            alert(result.message);
                            await loadMeetingTasks(currentSelectedMeetingTopic, currentSelectedMeetingDate);
                            await loadMeetingHistory();
                        } else {
                            alert('åˆªé™¤å¤±æ•—: ' + result.error);
                        }
                    } catch (error) {
                        console.error('Error deleting task:', error);
                        alert('åˆªé™¤ä»»å‹™æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚');
                    }
                }
            });

            // --- Modal Logic ---
            const modal = document.getElementById('edit-task-modal');
            const closeButton = modal.querySelector('.close-button');

            function closeModal() {
                modal.style.display = 'none';
            }

            closeButton.onclick = closeModal;
            window.onclick = function(event) {
                if (event.target == modal) {
                    closeModal();
                }
            }

            document.getElementById('edit-task-form').addEventListener('submit', async function(event) {
                event.preventDefault();
                const taskId = document.getElementById('edit-task-id').value;
                const data = {
                    task_description: document.getElementById('edit-task-description').value,
                    assigned_to_user_key: document.getElementById('edit-assigned-to-user-key').value,
                    controller_user_key: document.getElementById('edit-controller-user-key').value
                };

                if (!data.task_description.trim()) {
                    alert('ä»»å‹™äº‹é …ä¸å¯ç‚ºç©ºã€‚');
                    return;
                }

                try {
                    const response = await fetch(`/api/meeting_task/${taskId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    const result = await response.json();
                    if (response.ok) {
                        alert(result.message || 'ä»»å‹™å·²æˆåŠŸæ›´æ–°');
                        closeModal();
                        await loadMeetingTasks(currentSelectedMeetingTopic, currentSelectedMeetingDate);
                    } else {
                        alert('æ›´æ–°å¤±æ•—: ' + result.error);
                    }
                } catch (error) {
                    console.error('Error updating task via modal:', error);
                    alert('æ›´æ–°ä»»å‹™æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚');
                }
            });

            document.getElementById('update-discussion-topic-button').addEventListener('click', async function() {
                const newTopic = document.getElementById('discussion-topic').value;
                const currentMeetingTopic = document.getElementById('meeting-topic').value;
                const currentMeetingDate = document.getElementById('meeting-date').value;

                if (!newTopic.trim()) {
                    alert('è¨è«–è­°é¡Œå…§å®¹ä¸å¯ç‚ºç©ºã€‚');
                    return;
                }

                const chairmanUserKey = document.getElementById('chairman-user-key').value;
                const recorderUserKey = document.getElementById('recorder-user-key').value;
                const attendeesUserKeys = Array.from(document.getElementById('attendees-user-keys').selectedOptions).map(opt => opt.value);
                const location = document.getElementById('meeting-location').value;

                // Case 1: No historical meeting is selected (currentSelectedMeetingTopic is null)
                // This means the user is trying to create a brand new meeting/discussion.
                if (currentSelectedMeetingTopic === null) {
                    try {
                        const response = await fetch('/api/create_new_meeting_discussion', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                meeting_topic: currentMeetingTopic,
                                meeting_date: currentMeetingDate,
                                chairman_user_key: chairmanUserKey,
                                recorder_user_key: recorderUserKey,
                                attendees_user_keys: attendeesUserKeys,
                                discussion_topic: newTopic,
                                location: location
                            })
                        });
                        const result = await response.json();
                        if (response.ok) {
                            alert(result.message);
                            // æˆåŠŸå‰µå»ºå¾Œï¼Œæ›´æ–°ç•¶å‰é¸ä¸­çš„æœƒè­°è³‡è¨Šä¸¦é‡æ–°è¼‰å…¥ä»»å‹™å’Œæ­·å²
                            currentSelectedMeetingTopic = currentMeetingTopic;
                            currentSelectedMeetingDate = currentMeetingDate;
                            currentDiscussionItemId = result.discussion_item_id; // æ›´æ–°è¨è«–è­°é¡Œ ID
                            await loadMeetingTasks(currentSelectedMeetingTopic, currentSelectedMeetingDate);
                            await loadMeetingHistory();
                        } else {
                            alert('å‰µå»ºæ–°æœƒè­°å’Œè¨è«–è­°é¡Œå¤±æ•—: ' + result.error);
                        }
                    } catch (error) {
                        console.error('å‰µå»ºæ–°æœƒè­°å’Œè¨è«–è­°é¡Œæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                        alert('å‰µå»ºæ–°æœƒè­°å’Œè¨è«–è­°é¡Œæ™‚ç™¼ç”Ÿç¶²è·¯éŒ¯èª¤ã€‚');
                    }
                    return;
                } 
                // Case 2: A historical meeting is selected, and its topic or date has been modified
                else if (currentMeetingTopic !== currentSelectedMeetingTopic || (currentMeetingDate && currentSelectedMeetingDate && currentMeetingDate.split('T')[0] !== currentSelectedMeetingDate.split('T')[0])) {
                    const confirmation = confirm('æœƒè­°ä¸»é¡Œæˆ–æ—¥æœŸå·²ä¿®æ”¹ã€‚é€™å°‡å‰µå»ºä¸€å€‹æ–°çš„æœƒè­°å’Œè¨è«–è­°é¡Œã€‚æ˜¯å¦ç¹¼çºŒï¼Ÿ');
                    if (!confirmation) {
                        return;
                    }

                    try {
                        const response = await fetch('/api/create_new_meeting_discussion', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                meeting_topic: currentMeetingTopic,
                                meeting_date: currentMeetingDate,
                                chairman_user_key: chairmanUserKey,
                                recorder_user_key: recorderUserKey,
                                attendees_user_keys: attendeesUserKeys,
                                discussion_topic: newTopic,
                                location: location
                            })
                        });
                        const result = await response.json();
                        if (response.ok) {
                            alert(result.message);
                            // æˆåŠŸå‰µå»ºå¾Œï¼Œæ›´æ–°ç•¶å‰é¸ä¸­çš„æœƒè­°è³‡è¨Šä¸¦é‡æ–°è¼‰å…¥ä»»å‹™å’Œæ­·å²
                            currentSelectedMeetingTopic = currentMeetingTopic;
                            currentSelectedMeetingDate = currentMeetingDate;
                            currentDiscussionItemId = result.discussion_item_id; // æ›´æ–°è¨è«–è­°é¡Œ ID
                            await loadMeetingTasks(currentSelectedMeetingTopic, currentSelectedMeetingDate);
                            await loadMeetingHistory();
                        } else {
                            alert('å‰µå»ºæ–°æœƒè­°å’Œè¨è«–è­°é¡Œå¤±æ•—: ' + result.error);
                        }
                    } catch (error) {
                        console.error('å‰µå»ºæ–°æœƒè­°å’Œè¨è«–è­°é¡Œæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                        alert('å‰µå»ºæ–°æœƒè­°å’Œè¨è«–è­°é¡Œæ™‚ç™¼ç”Ÿç¶²è·¯éŒ¯èª¤ã€‚');
                    }
                    return;
                } 
                // Case 3: A historical meeting is selected, and only the discussion topic (or other fields not topic/date) is being updated
                else if (currentDiscussionItemId) {
                    try {
                        const response = await fetch(`/api/discussion_item/${currentDiscussionItemId}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                topic: newTopic,
                                recorder_user_key: recorderUserKey,
                                location: location,
                                meeting_date: currentMeetingDate // Pass the current form date for consistency
                            })
                        });
                        const result = await response.json();
                        if (response.ok) {
                            alert(result.message);
                            await loadMeetingTasks(currentSelectedMeetingTopic, currentSelectedMeetingDate);
                        } else {
                            alert('æ›´æ–°è¨è«–è­°é¡Œå¤±æ•—: ' + result.error);
                        }
                    } catch (error) {
                        console.error('Error updating discussion item:', error);
                        alert('æ›´æ–°è¨è«–è­°é¡Œæ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚');
                    }
                } else {
                    alert('ç„¡æ³•æ›´æ–°è¨è«–è­°é¡Œï¼Œè«‹å…ˆé¸æ“‡ä¸€å€‹æ­·å²æœƒè­°ã€‚');
                }
            });
        });
    </script>
        <script src="{{ url_for('static', filename='js/flatpickr/flatpickr.min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/flatpickr/zh-tw.js') }}"></script>
    <script>
</body>
</html>
